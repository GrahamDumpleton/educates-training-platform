# Note this is all included in a separate file so it can be sourced if
# necessary from special scripts run in init containers. So don't go
# merging it back into the start-container script.

# If we are not running in a Kubernetes cluster and a kubeconfig has not
# been mounted into the container, then disable any web console for the
# accessing a Kubernetes cluster.

KUBERNETES_SERVER=$KUBERNETES_PORT_443_TCP_ADDR:$KUBERNETES_PORT_443_TCP_PORT

if [ x"$KUBERNETES_SERVER" == x":" ]; then
    if [ -f /opt/eduk8s/config/kubeconfig.yaml ]; then
        KUBECONFIG=/opt/eduk8s/config/kubeconfig.yaml
        export KUBECONFIG
    fi
fi

# Try and work out the correct version of the command line tools to use
# if not explicitly specified in environment. This assumes you will be
# using the same cluster the deployment is to.

if [ "$KUBERNETES_SERVER" != ":" ]; then
    if [ -z "$KUBECTL_VERSION" ]; then
        KUBECTL_VERSION=`(curl -s -k https://$KUBERNETES_SERVER/version | \
            python3 -c 'from __future__ import print_function; import sys, json; \
            info = json.loads(sys.stdin.read()); \
            info and print("%s.%s" % (info["major"], info["minor"].rstrip("+")))') || true`
    fi
fi

if [ -z "$KUBECTL_VERSION" ]; then
    KUBECTL_VERSION=1.18
fi

if [ -z "$OC_VERSION" ]; then
    case "$KUBECTL_VERSION" in
        1.17|1.17+)
            OC_VERSION=4.4
            ;;
        1.18|1.18+)
            OC_VERSION=4.5
            ;;
        *)
            OC_VERSION=4.5
            ;;
    esac
fi

export KUBECTL_VERSION
export OC_VERSION

# Setup the client configuration for the location of the Kubernetes
# cluster along with credentials. We do this in case we need to use a
# program that will not use the in-cluster config and requires
# ~/.kube/config instead. Also allows us to use a bearer token which
# is passed into the container.

CA_FILE="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
NAMESPACE_FILE="/var/run/secrets/kubernetes.io/serviceaccount/namespace"
TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"

if [ "$KUBERNETES_SERVER" != ":" ]; then
    if [ -f $CA_FILE ]; then
        KUBECTL_CA_ARGS="--certificate-authority $CA_FILE"
    else
        KUBECTL_CA_ARGS="--insecure-skip-tls-verify"
    fi

    CURRENT_CLUSTER="in-cluster-config"

    kubectl config set-cluster $CURRENT_CLUSTER $KUBECTL_CA_ARGS --server "https://$KUBERNETES_SERVER"

    if [ ! -z "$SESSION_NAMESPACE" ]; then
        CURRENT_NAMESPACE=$SESSION_NAMESPACE
    else
        if [ -f $NAMESPACE_FILE ]; then
            CURRENT_NAMESPACE=`cat $NAMESPACE_FILE` 
        else
            CURRENT_NAMESPACE=default
        fi
    fi

    CURRENT_USER=eduk8s

    if [ ! -z "$KUBERNETES_BEARER_TOKEN" ]; then
        kubectl config set-credentials $CURRENT_USER --token=$KUBERNETES_BEARER_TOKEN
    else
        if [ -f "$TOKEN_FILE" ]; then
            kubectl config set-credentials $CURRENT_USER --token=`cat $TOKEN_FILE`
        fi
    fi

    CURRENT_CONTEXT=eduk8s

    kubectl config set-context $CURRENT_CONTEXT --cluster $CURRENT_CLUSTER --user $CURRENT_USER --namespace=$CURRENT_NAMESPACE

    kubectl config use-context $CURRENT_CONTEXT
fi

if [ -z "$SESSION_NAMESPACE" ]; then
    SESSION_NAMESPACE=$CURRENT_NAMESPACE
    if [ ! -z "$SESSION_NAMESPACE" ]; then
        export SESSION_NAMESPACE
    fi
fi

# Determine if there is a namespace corresponding to what was set or
# calculated as current namespace. If there isn't fallback to using the
# default namespace as necessary. This will be used in constructing URLs
# for web console, or in console startup scripts to restrict initial
# namespace accessed.
#

DEFAULT_NAMESPACE=$SESSION_NAMESPACE

set +eo pipefail

get ns "$DEFAULT_NAMESPACE" > /dev/null 2>&1

if [ "$?" != "0" ]; then
    DEFAULT_NAMESPACE=default
fi

set -eo pipefail

export DEFAULT_NAMESPACE

# Setup WebDAV configuration for when running Apache. Done here so that
# environment variables are available to the terminal to add an account.

if [ x"$ENABLE_WEBDAV" == x"true" ]; then
    mkdir -p /home/eduk8s/.webdav

    WEBDAV_REALM=workshop
    WEBDAV_USERFILE=/home/eduk8s/.webdav/users

    WEBDAV_USERNAME=$SESSION_NAMESPACE
    WEBDAV_PASSWORD=`python3 << !
import string
import random
characters = string.ascii_letters + string.digits
print("".join(random.sample(characters, 32)))
!`

    export WEBDAV_REALM
    export WEBDAV_USERFILE

    export WEBDAV_USERNAME
    export WEBDAV_PASSWORD

    (cat - | python3 > $WEBDAV_USERFILE) << !
import hashlib
dgst_md5 = hashlib.new("md5")
dgst_md5.update("$WEBDAV_USERNAME:$WEBDAV_REALM:$WEBDAV_PASSWORD".encode("utf-8"))
print("$WEBDAV_USERNAME:$WEBDAV_REALM:"+dgst_md5.hexdigest())
!
fi

# Set access credentials for working with image registries if supplied.
# The REGISTRY_AUTH_FILE environment is set for the image so that podman
# will use this file location instead of its default.

if [ x"$ENABLE_REGISTRY" == x"true" ]; then
    if [ ! -f /home/eduk8s/.docker/config.json ]; then
        mkdir -p /home/eduk8s/.docker
        if [ -f /var/run/registry/config.json ]; then
            cp /var/run/registry/config.json /home/eduk8s/.docker/
        fi
    fi

    if [ x"$INGRESS_PROTOCOL" == x"http" ]; then
        if [ ! -f /home/eduk8s/.config/containers/registries.conf ]; then
            mkdir -p /home/eduk8s/.config/containers
            cat > /home/eduk8s/.config/containers/registries.conf << EOF
[registries.insecure]
registries = ['$REGISTRY_HOST']
EOF
        fi
    fi
fi
